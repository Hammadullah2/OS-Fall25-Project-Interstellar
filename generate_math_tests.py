#!/usr/bin/env python3
import math
import random

def generate_sqrtf_tests():
    tests = []
    # Edge cases
    tests.append((0.0, 0.0))
    tests.append((-1.0, float('nan')))
    tests.append((1.0, 1.0))
    tests.append((4.0, 2.0))
    tests.append((float('inf'), float('inf')))
    
    # Perfect squares
    for i in range(2, 20):
        tests.append((i*i, float(i)))
    
    # Random positive numbers
    for _ in range(30):
        x = random.uniform(0.1, 10000.0)
        tests.append((x, math.sqrt(x)))
    
    # Very small numbers
    for _ in range(10):
        x = random.uniform(1e-10, 1e-5)
        tests.append((x, math.sqrt(x)))
    
    # Large numbers
    for _ in range(10):
        x = random.uniform(1e5, 1e10)
        tests.append((x, math.sqrt(x)))
    
    return tests

def generate_expf_tests():
    tests = []
    # Edge cases
    tests.append((0.0, 1.0))
    tests.append((1.0, math.exp(1)))
    tests.append((-1.0, math.exp(-1)))
    
    # Various ranges
    for _ in range(20):
        x = random.uniform(-5, 5)
        tests.append((x, math.exp(x)))
    
    # Large positive (overflow)
    tests.append((100.0, float('inf')))
    
    # Large negative (underflow)
    tests.append((-100.0, 0.0))
    
    # Small values
    for _ in range(10):
        x = random.uniform(-10, -5)
        tests.append((x, math.exp(x)))
    
    return tests

def generate_powf_tests():
    tests = []
    # Edge cases
    tests.append((0.0, 0.0, 1.0))  # 0^0 undefined but test it
    tests.append((2.0, 0.0, 1.0))  # x^0
    tests.append((1.0, 5.0, 1.0))  # 1^x
    tests.append((4.0, 0.5, 2.0))  # sqrt as pow
    
    # Integer exponents
    for base in [2.0, 3.0, 5.0]:
        for exp in range(-3, 4):
            tests.append((base, float(exp), math.pow(base, exp)))
    
    # Fractional exponents
    for base in [4.0, 9.0, 16.0]:
        for exp in [0.5, 0.25, 0.75]:
            tests.append((base, exp, math.pow(base, exp)))
    
    # Negative bases with odd integer exponents
    tests.append((-2.0, 3.0, -8.0))
    tests.append((-3.0, 2.0, 9.0))
    
    # Random cases
    for _ in range(20):
        x = random.uniform(0.1, 10.0)
        y = random.uniform(-3.0, 3.0)
        tests.append((x, y, math.pow(x, y)))
    
    return tests

def generate_trig_tests():
    sin_tests = []
    cos_tests = []
    
    # Standard angles
    angles = [0, math.pi/6, math.pi/4, math.pi/3, math.pi/2, math.pi, 
              2*math.pi, -math.pi/4, -math.pi/2, 3*math.pi/2]
    
    for angle in angles:
        sin_tests.append((angle, math.sin(angle)))
        cos_tests.append((angle, math.cos(angle)))
    
    # Large multiples of pi
    for mult in range(1, 6):
        angle = mult * math.pi
        sin_tests.append((angle, math.sin(angle)))
        cos_tests.append((angle, math.cos(angle)))
    
    # Negative angles
    for _ in range(10):
        angle = random.uniform(-10*math.pi, 10*math.pi)
        sin_tests.append((angle, math.sin(angle)))
        cos_tests.append((angle, math.cos(angle)))
    
    # Random angles
    for _ in range(30):
        angle = random.uniform(-100.0, 100.0)
        sin_tests.append((angle, math.sin(angle)))
        cos_tests.append((angle, math.cos(angle)))
    
    return sin_tests, cos_tests

def generate_fabsf_tests():
    tests = []
    # Edge cases
    tests.append((0.0, 0.0))
    tests.append((-0.0, 0.0))
    tests.append((1.0, 1.0))
    tests.append((-1.0, 1.0))
    tests.append((float('inf'), float('inf')))
    tests.append((-float('inf'), float('inf')))
    tests.append((float('nan'), float('nan')))
    
    # Various numbers
    for _ in range(50):
        x = random.uniform(-1000.0, 1000.0)
        tests.append((x, abs(x)))
    
    # Small numbers
    for _ in range(10):
        x = random.uniform(-1e-6, 1e-6)
        tests.append((x, abs(x)))
    
    return tests

def main():
    print("// Auto-generated math test vectors")
    print("// Generated by generate_math_tests.py")
    print("// DO NOT EDIT BY HAND")
    print()
    
    # Generate and output sqrt tests
    sqrt_tests = generate_sqrtf_tests()
    print(f"#define NUM_SQRT {len(sqrt_tests)}")
    print("float sqrt_inputs[NUM_SQRT] = {")
    for inp, _ in sqrt_tests:
        print(f"    {inp}f,")
    print("};")
    print("float sqrt_expected[NUM_SQRT] = {")
    for _, out in sqrt_tests:
        if math.isnan(out):
            print("    NAN,")
        else:
            print(f"    {out}f,")
    print("};")
    print()
    
    # Generate and output exp tests
    exp_tests = generate_expf_tests()
    print(f"#define NUM_EXP {len(exp_tests)}")
    print("float exp_inputs[NUM_EXP] = {")
    for inp, _ in exp_tests:
        print(f"    {inp}f,")
    print("};")
    print("float exp_expected[NUM_EXP] = {")
    for _, out in exp_tests:
        if math.isnan(out):
            print("    NAN,")
        else:
            print(f"    {out}f,")
    print("};")
    print()
    
    # Generate and output pow tests
    pow_tests = generate_powf_tests()
    print(f"#define NUM_POW {len(pow_tests)}")
    print("float pow_x[NUM_POW] = {")
    for x, _, _ in pow_tests:
        print(f"    {x}f,")
    print("};")
    print("float pow_y[NUM_POW] = {")
    for _, y, _ in pow_tests:
        print(f"    {y}f,")
    print("};")
    print("float pow_expected[NUM_POW] = {")
    for _, _, out in pow_tests:
        if math.isnan(out):
            print("    NAN,")
        else:
            print(f"    {out}f,")
    print("};")
    print()
    
    # Generate and output trig tests
    sin_tests, cos_tests = generate_trig_tests()
    print(f"#define NUM_TRIG {len(sin_tests)}")
    print("float sin_inputs[NUM_TRIG] = {")
    for inp, _ in sin_tests:
        print(f"    {inp}f,")
    print("};")
    print("float sin_expected[NUM_TRIG] = {")
    for _, out in sin_tests:
        print(f"    {out}f,")
    print("};")
    print("float cos_inputs[NUM_TRIG] = {")
    for inp, _ in cos_tests:
        print(f"    {inp}f,")
    print("};")
    print("float cos_expected[NUM_TRIG] = {")
    for _, out in cos_tests:
        print(f"    {out}f,")
    print("};")
    print()
    
    # Generate and output fabs tests
    fabs_tests = generate_fabsf_tests()
    print(f"#define NUM_FABS {len(fabs_tests)}")
    print("float fabs_inputs[NUM_FABS] = {")
    for inp, _ in fabs_tests:
        print(f"    {inp}f,")
    print("};")
    print("float fabs_expected[NUM_FABS] = {")
    for _, out in fabs_tests:
        if math.isnan(out):
            print("    NAN,")
        else:
            print(f"    {out}f,")
    print("};")

if __name__ == "__main__":
    main()